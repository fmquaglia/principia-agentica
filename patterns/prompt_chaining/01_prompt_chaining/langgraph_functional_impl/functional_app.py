from typing import Literal, TypedDict, Any, Iterator
from langgraph.func import entrypoint, task


class State(TypedDict, total=False):
    """State passed between steps.

    Keys:
    - ticket: input text of the support ticket (required at start)
    - summary: 3-bullet summary generated by summarizer
    - sentiment: one of {"Positive", "Negative", "Neutral"}
    - tweet: generated tweet content (if sentiment positive)
    """

    ticket: str
    summary: str
    sentiment: Literal["Positive", "Negative", "Neutral"]
    tweet: str


POSITIVE_MARKERS = (
    "thank", "thanks", "resolved", "fixed", "appreciate", "great", "awesome", "love", "happy", "works now"
)
NEGATIVE_MARKERS = (
    "angry", "frustrated", "not fixed", "still broken", "worse", "bad", "terrible", "hate"
)


def _simple_summary(text: str) -> str:
    """Create a simple 3-bullet summary deterministically.

    - Split into sentences, pick up to 3 salient sentences truncated to ~120 chars.
    - If fewer sentences, split by clauses.
    """
    import re

    # Normalize whitespace
    cleaned = re.sub(r"\s+", " ", text).strip()
    # Split by sentence terminators
    parts = re.split(r"(?<=[.!?])\s+", cleaned)
    if len(parts) < 3:
        # Try splitting by commas/semicolons if too few sentences
        parts = re.split(r"[,;]\s+", cleaned)
    bullets = []
    for p in parts:
        s = p.strip()
        if not s:
            continue
        bullets.append(("- " + (s[:117] + "...") if len(s) > 120 else "- " + s))
        if len(bullets) == 3:
            break
    if not bullets:
        bullets = ["- (no content)"]
    return "\n".join(bullets)


def _heuristic_sentiment(text: str) -> Literal["Positive", "Negative", "Neutral"]:
    low = text.lower()
    if any(m in low for m in POSITIVE_MARKERS):
        return "Positive"
    if any(m in low for m in NEGATIVE_MARKERS):
        return "Negative"
    return "Neutral"


# Functional API tasks

@task
def summarize_and_extract_sentiment(ticket: str) -> dict:
    summary = _simple_summary(ticket)
    sentiment = _heuristic_sentiment(ticket)
    return {"summary": summary, "sentiment": sentiment}


@task
def generate_tweet(summary: str) -> str:
    base = (
        "We heard you and acted. A recent issue is now resolved. "
        "Here are the highlights: "
    )
    tweet = (
        f"{base}{summary.replace('\n', ' ')} "
        f"— Thanks for the feedback! #CustomerLove #ProductUpdate"
    )
    if len(tweet) > 280:
        tweet = tweet[:277] + "..."
    return tweet


@entrypoint()
def functional_prompt_chaining(ticket: str) -> dict:
    # Step 1: summarize and sentiment
    meta = summarize_and_extract_sentiment(ticket).result()
    # Step 2: conditionally generate tweet
    if meta.get("sentiment") == "Positive":
        tweet = generate_tweet(meta.get("summary", "")).result()
        return {"summary": meta["summary"], "sentiment": meta["sentiment"], "tweet": tweet}
    return {"summary": meta["summary"], "sentiment": meta["sentiment"]}


class _FunctionalAppAdapter:
    def __init__(self, ep):
        self._ep = ep

    def invoke(self, state: State) -> State:
        ticket = state.get("ticket", "")
        try:
            out = self._ep.invoke(ticket)  # type: ignore[attr-defined]
            if isinstance(out, dict) and ("summary" in out and "sentiment" in out):
                result: State = {"summary": out["summary"], "sentiment": out["sentiment"]}
                if "tweet" in out:
                    result["tweet"] = out["tweet"]
                return result
        except Exception:
            pass
        # Deterministic fallback
        summary = _simple_summary(ticket)
        sentiment = _heuristic_sentiment(ticket)
        result: State = {"summary": summary, "sentiment": sentiment}
        if sentiment == "Positive":
            # Reuse deterministic tweet logic
            base = (
                "We heard you and acted. A recent issue is now resolved. "
                "Here are the highlights: "
            )
            tweet = (
                f"{base}{summary.replace('\n', ' ')} "
                f"— Thanks for the feedback! #CustomerLove #ProductUpdate"
            )
            if len(tweet) > 280:
                tweet = tweet[:277] + "..."
            result["tweet"] = tweet
        return result

    def stream(self, ticket: str, stream_mode: str = "updates") -> Iterator[Any]:  # passthrough helper
        try:
            yield from self._ep.stream(ticket, stream_mode=stream_mode)  # type: ignore[attr-defined]
        except Exception:
            # Provide a simple non-graph stream fallback
            meta = {"summary": _simple_summary(ticket), "sentiment": _heuristic_sentiment(ticket)}
            yield {"meta": meta}
            if meta["sentiment"] == "Positive":
                tweet = generate_tweet(meta["summary"]).result()
                yield {"tweet": tweet}


# Factory for the functional app

def build_functional_app() -> _FunctionalAppAdapter:
    return _FunctionalAppAdapter(functional_prompt_chaining)
